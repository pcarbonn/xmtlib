(set-option :backend none)

(declare-datatype node ( (n1) (n2) ))

(declare-fun edge    (node node) Bool)
(declare-fun reaches (node node) Bool)
(declare-fun level   (node node) Real)

; using level mapping
(assert (forall ((X node) (Y node))
                (= (reaches X Y)
                   (or (edge X Y)
                       (exists ((Z node))
                               (and (edge X Z)
                                    (reaches Z Y) (< (level Z Y) (level X Y)))
                       )))))

(x-interpret-pred edge (x-set (n1 n2) ))
(x-ground :debug :sql)
(x-debug solver generators)
------- RESULTS ------------------
(declare-datatype node ((n1) (n2)))
(declare-fun edge (node node) Bool)
(declare-fun reaches (node node) Bool)
(declare-fun level (node node) Real)
; ==== Query =============================
;-- Agg (0)
;SELECT G as G
; FROM (-- Join(7)
;       SELECT _xmt_view_reaches_2_4.X AS X,
;              _xmt_view_reaches_2_4.Y AS Y,
;              bool_eq_("true", _xmt_view_reaches_2_4.G, _xmt_view_or_12.G) AS G
;         FROM (-- Join(15)
;               SELECT _xmt_sort_node.G AS X,
;                      _xmt_sort_node_1.G AS Y,
;                      apply("reaches", _xmt_sort_node.G, _xmt_sort_node_1.G) AS G
;                 FROM _xmt_sort_node
;                 JOIN _xmt_sort_node AS _xmt_sort_node_1
;               ) AS _xmt_view_reaches_2_4
;         FULL JOIN (-- Join(15)
;               SELECT _xmt_interp_edge_UF_3.a_1 AS X,
;                      _xmt_interp_edge_UF_3.a_2 AS Y,
;                      Agg_11_UF.G AS G
;                 FROM (-- Agg (23)
;                       SELECT X, Y,
;                              or_aggregate(G) as G
;                        FROM (SELECT _xmt_sort_node.G AS X, NULL AS Z, _xmt_sort_node_1.G AS Y, "false" AS G FROM _xmt_sort_node AS _xmt_sort_node JOIN _xmt_sort_node AS _xmt_sort_node_1 
;                              UNION ALL
;                              -- Join(30)
;                              SELECT _xmt_interp_edge_TU_5.a_1 AS X,
;                                     _xmt_interp_edge_TU_5.a_2 AS Z,
;                                     _xmt_sort_node_1.G AS Y,
;                                     and_(apply("reaches", _xmt_interp_edge_TU_5.a_2, _xmt_sort_node_1.G), apply("<", apply("level", _xmt_interp_edge_TU_5.a_2, _xmt_sort_node_1.G), apply("level", _xmt_interp_edge_TU_5.a_1, _xmt_sort_node_1.G))) AS G
;                                FROM _xmt_sort_node AS _xmt_sort_node_1
;                                JOIN _xmt_interp_edge_TU AS _xmt_interp_edge_TU_5)
;                        GROUP BY X, Y
;                       ) AS Agg_11_UF
;                 JOIN _xmt_interp_edge_UF AS _xmt_interp_edge_UF_3
;                WHERE  Agg_11_UF.X = _xmt_interp_edge_UF_3.a_1 
;                       AND  Agg_11_UF.Y = _xmt_interp_edge_UF_3.a_2
;               ) AS _xmt_view_or_12 ON  _xmt_view_or_12.X = _xmt_view_reaches_2_4.X 
;               AND  _xmt_view_or_12.Y = _xmt_view_reaches_2_4.Y)(assert (= (reaches n1 n1) (and (reaches n2 n1) (< (level n2 n1) (level n1 n1)))))
(assert (= (reaches n1 n2) true))
(assert (= (reaches n2 n1) false))
(assert (= (reaches n2 n2) false))

; ==== Query =============================
;SELECT "true"
Generators:
=== (forall ((X node) (Y node)) (= (reaches X Y) (or (edge X Y) (exists ((Z node)) (and (edge X Z) (reaches Z Y) (< (level Z Y) (level X Y))))))) ======================================
TODO: generator
===========================================
