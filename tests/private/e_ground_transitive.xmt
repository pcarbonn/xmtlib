
(set-option :backend none)
(declare-fun Edge (Int Int) Bool)
(x-interpret-pred Edge
    (x-set
        (1 2)
        (2 1)
        (1 3)
    )
)
(assert (forall ((x Int) (y Int) (z Int))
            (=> (and (Edge x y) (Edge y z) )
                (Edge x z)
            )))

(x-ground :debug :sql)
(x-debug solver functions)
(x-debug solver generators)
------- RESULTS ------------------
(declare-fun Edge (Int Int) Bool)
; ==== Query =============================
;-- Agg (0)
;SELECT G as G
; FROM (-- Join(7)
;       SELECT _xmt_interp_edge_TU_2.a_1 AS x,
;              _xmt_interp_edge_TU_2.a_2 AS y,
;              _xmt_interp_edge_TU_5.a_2 AS z,
;              apply("Edge", _xmt_interp_edge_TU_2.a_1, _xmt_interp_edge_TU_5.a_2) AS G
;         FROM _xmt_interp_edge_TU AS _xmt_interp_edge_TU_2
;         JOIN _xmt_interp_edge_TU AS _xmt_interp_edge_TU_5
;               ON _xmt_interp_edge_TU_2.a_2 = _xmt_interp_edge_TU_5.a_1)(assert (Edge 1 1))
(assert (Edge 2 2))
(assert (Edge 2 3))
(assert (forall ((x0 Int) (x1 Int)) (= (Edge x0 x1) (or 
  (and (= x0 1) (= x1 2))
  (and (= x0 2) (= x1 1))
  (and (= x0 1) (= x1 3))
))))

; ==== Query =============================
;SELECT "true"
Functions2:
 - true ()->Bool : Constructor
 - false ()->Bool : Constructor
 - not ()->Bool : Predefined (true)
 - => ()->Bool : Predefined (true)
 - and ()->Bool : Predefined (true)
 - or ()->Bool : Predefined (true)
 - xor ()->Bool : Predefined (true)
 - = ()->Bool : Predefined (true)
 - distinct ()->Bool : Predefined (true)
 - <= ()->Bool : Predefined (true)
 - < ()->Bool : Predefined (true)
 - >= ()->Bool : Predefined (true)
 - > ()->Bool : Predefined (true)
 - ite ()->Bool : Predefined (?)
 - let ()->Bool : Predefined (?)
 - + ()->Real : Predefined (false)
 - - ()->Real : Predefined (false)
 - * ()->Real : Predefined (false)
 - div ()->Real : Predefined (false)
 - mod ()->Real : Predefined (false)
 - abs ()->Real : Predefined (false)
 - Edge (Int, Int)->Bool : Boolean (_xmt_interp_edge_TU Complete, (infinite), (infinite))
Generators:
=== (forall ((x Int) (y Int) (z Int)) (or (not (Edge x y)) (not (Edge y z)) (Edge x z))) ======================================
TODO: generator
===========================================
